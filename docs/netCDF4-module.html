<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>netCDF4</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        Module&nbsp;netCDF4
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module netCDF4</h1><p class="nomargin-top"></p>
<h1 class="heading">Introduction</h1>
    <p>Python interface to the netCDF version 4 library.  <a 
    href="http://www.unidata.ucar.edu/software/netcdf/netcdf-4" 
    target="_top">netCDF version 4</a> has many features not found in 
    earlier versions of the library and is implemented on top of <a 
    href="http://www.hdfgroup.org/HDF5" target="_top">HDF5</a>. This module
    can read and write files in both the new netCDF 4 and the old netCDF 3 
    format, and can create files that are readable by HDF5 clients. The API
    modelled after <a 
    href="http://dirac.cnrs-orleans.fr/plone/software/scientificpython/" 
    target="_top">Scientific.IO.NetCDF</a>, and should be familiar to users
    of that module.</p>
    <p>Most new features of netCDF 4 are implemented, such as multiple 
    unlimited dimensions, groups and zlib data compression.  All the new 
    numeric data types (such as 64 bit and unsigned integer types) are 
    implemented. Compound and variable length (vlen) data types are 
    supported, but the enum and opaque data types are not. Mixtures of 
    compound and vlen data types (compound types containing vlens, and 
    vlens containing compound types) are not supported.</p>
  <h1 class="heading">Download</h1>
    <ul>
      <li>
        Latest bleeding-edge code from the <a 
        href="http://code.google.com/p/netcdf4-python/source" 
        target="_top">subversion repository</a>.
      </li>
      <li>
        Latest <a 
        href="http://code.google.com/p/netcdf4-python/downloads/list" 
        target="_top">releases</a> (source code and windows installers).
      </li>
    </ul>
  <h1 class="heading">Requires</h1>
    <ul>
      <li>
        numpy array module <a href="http://numpy.scipy.org" 
        target="_top">http://numpy.scipy.org</a>, version 1.2.1 or later.
      </li>
      <li>
        The HDF5 C library version 1.8.4-patch1 or higher from <a 
        href="ftp://ftp.hdfgroup.org/HDF5/current/src" 
        target="_top">ftp://ftp.hdfgroup.org/HDF5/current/src</a>. Be sure 
        to build with '<code>--enable-hl --enable-shared</code>'.
      </li>
      <li>
        <a href="http://curl.haxx.se/libcurl/" target="_top">Libcurl</a>, 
        if you want <a href="http://opendap.org/" target="_top">OPeNDAP</a>
        support.
      </li>
      <li>
        The netCDF-4 C library from <a 
        href="ftp://ftp.unidata.ucar.edu/pub/netcdf" 
        target="_top">ftp://ftp.unidata.ucar.edu/pub/netcdf</a>. Version 
        4.1.1 or higher is required. Be sure to build with 
        '<code>--enable-netcdf-4 --with-hdf5=$HDF5_DIR 
        --enable-shared</code>', and '<code>--enable-dap</code>' if you 
        want <a href="http://opendap.org/" target="_top">OPeNDAP</a> 
        support. <code>$HDF5_DIR</code> is the directory where HDF5 was 
        installed.
      </li>
    </ul>
  <h1 class="heading">Install</h1>
    <ul>
      <li>
        install the requisite python modules and C libraries (see above).
      </li>
      <li>
        optionally, set the <code>HDF5_DIR</code> environment variable to 
        point to where HDF5 is installed (the libs in 
        <code>$HDF5_DIR/lib</code>, the headers in 
        <code>$HDF5_DIR/include</code>). If the headers and libs are 
        installed in different places, you can use <code>HDF5_INCDIR</code>
        and <code>HDF5_LIBDIR</code> to define the locations of the headers
        and libraries independently.
      </li>
      <li>
        optionally, set the <code>NETCDF4_DIR</code> (or 
        <code>NETCDF4_INCDIR</code> and <code>NETCDF4_LIBDIR</code>) 
        environment variable(s) to point to where the netCDF version 4 
        library and headers are installed.
      </li>
      <li>
        If the locations of the HDF5 and netCDF libs and headers are not 
        specified with environment variables, some standard locations will 
        be searched.
      </li>
      <li>
        if HDF5 was build with <a 
        href="http://www.hdfgroup.org/doc_resource/SZIP/" 
        target="_top">szip</a>, you may also need to set the 
        <code>SZIP_DIR</code> (or <code>SZIP_INCDIR</code> and 
        <code>SZIP_LIBDIR</code>) environment variable(s) to point to where
        szip is installed. Note that the netCDF library does not support 
        creating szip compressed files, but can read szip compressed files 
        if the HDF5 lib is configured to support szip.
      </li>
      <li>
        run 'python setup.py install'
      </li>
      <li>
        run the tests in the 'test' directory by running <code>python 
        run_all.py</code>.
      </li>
    </ul>
  <h1 class="heading">Tutorial</h1>
    <h2 class="heading">1) Creating/Opening/Closing a netCDF file</h2>
      <p>To create a netCDF file from python, you simply call the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      constructor. This is also the method used to open an existing netCDF 
      file.  If the file is open for write access (<code>w, r+</code> or 
      <code>a</code>), you may write any type of data including new 
      dimensions, groups, variables and attributes.  netCDF files come in 
      several flavors (<code>NETCDF3_CLASSIC, NETCDF3_64BIT, 
      NETCDF4_CLASSIC</code>, and <code>NETCDF4</code>). The first two 
      flavors are supported by version 3 of the netCDF library. 
      <code>NETCDF4_CLASSIC</code> files use the version 4 disk format 
      (HDF5), but do not use any features not found in the version 3 API. 
      They can be read by netCDF 3 clients only if they have been relinked 
      against the netCDF 4 library. They can also be read by HDF5 clients. 
      <code>NETCDF4</code> files use the version 4 disk format (HDF5) and 
      use the new features of the version 4 API.  The <code>netCDF4</code> 
      module can read and write files in any of these formats. When 
      creating a new file, the format may be specified using the 
      <code>format</code> keyword in the <code>Dataset</code> constructor.
      The default format is <code>NETCDF4</code>. To see how a given file 
      is formatted, you can examine the <code>file_format</code> <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> attribute.
      Closing the netCDF file is accomplished via the <a 
      href="netCDF4.Dataset-class.html#close" class="link">close</a> method
      of the <a href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.</p>
      <p>Here's an example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> Dataset
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'w'</span>, format=<span class="py-string">'NETCDF4'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.file_format
<span class="py-output">NETCDF4</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.close()</pre>
      <p>Remote <a href="http://opendap.org" 
      target="_top">OPeNDAP</a>-hosted datasets can be accessed for reading
      over http if a URL is provided to the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      constructor instead of a filename.  However, this requires that the 
      netCDF library be built with OPenDAP support, via the 
      <code>--enable-dap</code> configure option (added in version 
      4.0.1).</p>
    <h2 class="heading">2) Groups in a netCDF file</h2>
      <p>netCDF version 4 added support for organizing data in hierarchical
      groups, which are analagous to directories in a filesystem. Groups 
      serve as containers for variables, dimensions and attributes, as well
      as other groups.  A <code>netCDF4.Dataset</code> defines creates a 
      special group, called the 'root group', which is similar to the root 
      directory in a unix filesystem.  To create <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances, use
      the <a href="netCDF4.Dataset-class.html#createGroup" 
      class="link">createGroup</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. <a 
      href="netCDF4.Dataset-class.html#createGroup" 
      class="link">createGroup</a> takes a single argument, a python string
      containing the name of the new group. The new <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances 
      contained within the root group can be accessed by name using the 
      <code>groups</code> dictionary attribute of the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> instance.
      Only <code>NETCDF4</code> formatted files support Groups, if you try 
      to create a Group in a netCDF 3 file you will get an error 
      message.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'a'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp = rootgrp.createGroup(<span class="py-string">'forecasts'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>analgrp = rootgrp.createGroup(<span class="py-string">'analyses'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.groups
<span class="py-output">{'analyses': &lt;netCDF4._Group object at 0x24a54c30&gt;, </span>
<span class="py-output"> 'forecasts': &lt;netCDF4._Group object at 0x24a54bd0&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Groups can exist within groups in a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, just as 
      directories exist within directories in a unix filesystem. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance has a
      <code>'groups'</code> attribute dictionary containing all of the 
      group instances contained within that group. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance also 
      has a <code>'path'</code> attribute that contains a simulated unix 
      directory path to that group.</p>
      <p>Here's an example that shows how to navigate all the groups in a 
      <a href="netCDF4.Dataset-class.html" class="link">Dataset</a>. The 
      function <code>walktree</code> is a Python generator that is used to 
      walk the directory tree.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp1 = fcstgrp.createGroup(<span class="py-string">'model1'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp2 = fcstgrp.createGroup(<span class="py-string">'model2'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">walktree</span>(top):
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-builtin">values</span> = top.groups.values()
<span class="py-prompt">&gt;&gt;&gt; </span>    yield <span class="py-builtin">values</span>
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">for</span> value <span class="py-keyword">in</span> top.groups.values():
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(value):
<span class="py-prompt">&gt;&gt;&gt; </span>            yield children
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.path, rootgrp
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(rootgrp):
<span class="py-prompt">&gt;&gt;&gt; </span>     <span class="py-keyword">for</span> child <span class="py-keyword">in</span> children:
<span class="py-prompt">&gt;&gt;&gt; </span>         <span class="py-keyword">print</span> child.path, child
<span class="py-output">/ &lt;netCDF4.Dataset object at 0x24a54c00&gt;</span>
<span class="py-output">/analyses &lt;netCDF4.Group object at 0x24a54c30&gt;</span>
<span class="py-output">/forecasts &lt;netCDF4.Group object at 0x24a54bd0&gt;</span>
<span class="py-output">/forecasts/model2 &lt;netCDF4.Group object at 0x24a54cc0&gt;</span>
<span class="py-output">/forecasts/model1 &lt;netCDF4.Group object at 0x24a54c60&gt;</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
    <h2 class="heading">3) Dimensions in a netCDF file</h2>
      <p>netCDF defines the sizes of all variables in terms of dimensions, 
      so before any variables can be created the dimensions they use must 
      be created first. A special case, not often used in practice, is that
      of a scalar variable, which has no dimensions. A dimension is created
      using the <a href="netCDF4.Dataset-class.html#createDimension" 
      class="link">createDimension</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. A 
      Python string is used to set the name of the dimension, and an 
      integer value is used to set the size. To create an unlimited 
      dimension (a dimension that can be appended to), the size value is 
      set to <code>None</code> or 0. In this example, there both the 
      <code>time</code> and <code>level</code> dimensions are unlimited.  
      Having more than one unlimited dimension is a new netCDF 4 feature, 
      in netCDF 3 files there may be only one, and it must be the first 
      (leftmost) dimension of the variable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'level'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'time'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'lat'</span>, 73)
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.createDimension(<span class="py-string">'lon'</span>, 144)</pre>
      <p>All of the <a href="netCDF4.Dimension-class.html" 
      class="link">Dimension</a> instances are stored in a python 
      dictionary.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.dimensions
<span class="py-output">{'lat': &lt;netCDF4.Dimension object at 0x24a5f7b0&gt;, </span>
<span class="py-output"> 'time': &lt;netCDF4.Dimension object at 0x24a5f788&gt;, </span>
<span class="py-output"> 'lon': &lt;netCDF4.Dimension object at 0x24a5f7d8&gt;, </span>
<span class="py-output"> 'level': &lt;netCDF4.Dimension object at 0x24a5f760&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Calling the python <code>len</code> function with a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance returns the current size of that dimension. The <a 
      href="netCDF4.Dimension-class.html#isunlimited" 
      class="link">isunlimited</a> method of a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance can be used to determine if the dimensions is unlimited, or 
      appendable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> dimname, dimobj <span class="py-keyword">in</span> rootgrp.dimensions.iteritems():
<span class="py-prompt">&gt;&gt;&gt; </span>   <span class="py-keyword">print</span> dimname, len(dimobj), dimobj.isunlimited()
<span class="py-output">lat 73 False</span>
<span class="py-output">time 0 True</span>
<span class="py-output">lon 144 False</span>
<span class="py-output">level 0 True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      names can be changed using the <a 
      href="netCDF4.Dataset-class.html#renameDimension" 
      class="link">renameDimension</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance.</p>
    <h2 class="heading">4) Variables in a netCDF file</h2>
      <p>netCDF variables behave much like python multidimensional array 
      objects supplied by the <a href="http://numpy.scipy.org" 
      target="_top">numpy module</a>. However, unlike numpy arrays, netCDF4
      variables can be appended to along one or more 'unlimited' 
      dimensions. To create a netCDF variable, use the <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. The 
      <a href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method has two mandatory arguments, 
      the variable name (a Python string), and the variable datatype. The 
      variable's dimensions are given by a tuple containing the dimension 
      names (defined previously with <a 
      href="netCDF4.Dataset-class.html#createDimension" 
      class="link">createDimension</a>). To create a scalar variable, 
      simply leave out the dimensions keyword. The variable primitive 
      datatypes correspond to the dtype attribute of a numpy array. You can
      specify the datatype as a numpy dtype object, or anything that can be
      converted to a numpy dtype object.  Valid datatype specifiers 
      include: <code>'f4'</code> (32-bit floating point), <code>'f8'</code>
      (64-bit floating point), <code>'i4'</code> (32-bit signed integer), 
      <code>'i2'</code> (16-bit signed integer), <code>'i8'</code> (64-bit 
      singed integer), <code>'i1'</code> (8-bit signed integer), 
      <code>'u1'</code> (8-bit unsigned integer), <code>'u2'</code> (16-bit
      unsigned integer), <code>'u4'</code> (32-bit unsigned integer), 
      <code>'u8'</code> (64-bit unsigned integer), or <code>'S1'</code> 
      (single-character string).  The old Numeric single-character 
      typecodes (<code>'f'</code>,<code>'d'</code>,<code>'h'</code>, 
      <code>'s'</code>,<code>'b'</code>,<code>'B'</code>,<code>'c'</code>,<code>'i'</code>,<code>'l'</code>),
      corresponding to 
      (<code>'f4'</code>,<code>'f8'</code>,<code>'i2'</code>,<code>'i2'</code>,<code>'i1'</code>,<code>'i1'</code>,<code>'S1'</code>,<code>'i4'</code>,<code>'i4'</code>),
      will also work. The unsigned integer types and the 64-bit integer 
      type can only be used if the file format is <code>NETCDF4</code>.</p>
      <p>The dimensions themselves are usually also defined as variables, 
      called coordinate variables. The <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method returns an instance of the <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> class 
      whose methods can be used later to access and set variable data and 
      attributes.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>times = rootgrp.createVariable(<span class="py-string">'time'</span>,<span class="py-string">'f8'</span>,(<span class="py-string">'time'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>levels = rootgrp.createVariable(<span class="py-string">'level'</span>,<span class="py-string">'i4'</span>,(<span class="py-string">'level'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes = rootgrp.createVariable(<span class="py-string">'latitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lat'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes = rootgrp.createVariable(<span class="py-string">'longitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lon'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># two dimensions unlimited.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      <p>All of the variables in the <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> are stored in a Python dictionary, in the same
      way as the dimensions:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.variables
<span class="py-output">{'temp': &lt;netCDF4.Variable object at 0x24a61068&gt;,</span>
<span class="py-output"> 'level': &lt;netCDF4.Variable object at 0.35f0f80&gt;, </span>
<span class="py-output"> 'longitude': &lt;netCDF4.Variable object at 0x24a61030&gt;,</span>
<span class="py-output"> 'pressure': &lt;netCDF4.Variable object at 0x24a610a0&gt;, </span>
<span class="py-output"> 'time': &lt;netCDF4.Variable object at 02x45f0.4.58&gt;, </span>
<span class="py-output"> 'latitude': &lt;netCDF4.Variable object at 0.3f0fb8&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4.Variable-class.html" class="link">Variable</a> 
      names can be changed using the <a 
      href="netCDF4.Dataset-class.html#renameVariable" 
      class="link">renameVariable</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.</p>
    <h2 class="heading">5) Attributes in a netCDF file</h2>
      <p>There are two types of attributes in a netCDF file, global and 
      variable. Global attributes provide information about a group, or the
      entire dataset, as a whole. <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> attributes provide information about one of
      the variables in a group. Global attributes are set by assigning 
      values to <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> instance variables. <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      attributes are set by assigning values to <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      instances variables. Attributes can be strings, numbers or sequences.
      Returning to our example,</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> time
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.description = <span class="py-string">'bogus example script'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.history = <span class="py-string">'Created '</span> + time.ctime(time.time())
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.source = <span class="py-string">'netCDF4 python module tutorial'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes.units = <span class="py-string">'degrees north'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes.units = <span class="py-string">'degrees east'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>pressure.units = <span class="py-string">'hPa'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp.units = <span class="py-string">'K'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.units = <span class="py-string">'hours since 0001-01-01 00:00:00.0'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.calendar = <span class="py-string">'gregorian'</span></pre>
      <p>The <a href="netCDF4.Dataset-class.html#ncattrs" 
      class="link">ncattrs</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      can be used to retrieve the names of all the netCDF attributes. This 
      method is provided as a convenience, since using the built-in 
      <code>dir</code> Python function will return a bunch of private 
      methods and attributes that cannot (or should not) be modified by the
      user.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> name <span class="py-keyword">in</span> rootgrp.ncattrs():
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">print</span> <span class="py-string">'Global attr'</span>, name, <span class="py-string">'='</span>, getattr(rootgrp,name)
<span class="py-output">Global attr description = bogus example script</span>
<span class="py-output">Global attr history = Created Mon Nov  7 10.30:56 2005</span>
<span class="py-output">Global attr source = netCDF4 python module tutorial</span></pre>
      <p>The <code>__dict__</code> attribute of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      provides all the netCDF attribute name/value pairs in a python 
      dictionary:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.__dict__
<span class="py-output">{'source': 'netCDF4 python module tutorial',</span>
<span class="py-output">'description': 'bogus example script',</span>
<span class="py-output">'history': 'Created Mon Nov  7 10.30:56 2005'}</span></pre>
      <p>Attributes can be deleted from a netCDF <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> using 
      the python <code>del</code> statement (i.e. <code>del grp.foo</code> 
      removes the attribute <code>foo</code> the the group 
      <code>grp</code>).</p>
    <h2 class="heading">6) Writing data to and retrieving data from a netCDF variable</h2>
      <p>Now that you have a netCDF <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> instance, how do you put data into it? You 
      can just treat it like an array and assign data to a slice.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> numpy 
<span class="py-prompt">&gt;&gt;&gt; </span>lats =  numpy.arange(-90,91,2.5)
<span class="py-prompt">&gt;&gt;&gt; </span>lons =  numpy.arange(-180,180,2.5)
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes[:] = lats
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes[:] = lons
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'latitudes =\n'</span>,latitudes[:]
<span class="py-output">latitudes =</span>
<span class="py-output">[-90.  -87.5 -85.  -82.5 -80.  -77.5 -75.  -72.5 -70.  -67.5 -65.  -62.5</span>
<span class="py-output"> -60.  -57.5 -55.  -52.5 -50.  -47.5 -45.  -42.5 -40.  -37.5 -35.  -32.5</span>
<span class="py-output"> -30.  -27.5 -25.  -22.5 -20.  -17.5 -15.  -12.5 -10.   -7.5  -5.   -2.5</span>
<span class="py-output">   0.    2.5   5.    7.5  10.   12.5  15.   17.5  20.   22.5  25.   27.5</span>
<span class="py-output">  30.   32.5  35.   37.5  40.   42.5  45.   47.5  50.   52.5  55.   57.5</span>
<span class="py-output">  60.   62.5  65.   67.5  70.   72.5  75.   77.5  80.   82.5  85.   87.5</span>
<span class="py-output">  90. ]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Unlike NumPy's array objects, netCDF <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> objects 
      with unlimited dimensions will grow along those dimensions if you 
      assign data outside the currently defined range of indices.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># append along two unlimited dimensions by assigning to slice.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nlats = len(rootgrp.dimensions[<span class="py-string">'lat'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span>nlons = len(rootgrp.dimensions[<span class="py-string">'lon'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape before adding data = '</span>,temp.shape
<span class="py-output">temp shape before adding data =  (0, 0, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.random <span class="py-keyword">import</span> uniform
<span class="py-prompt">&gt;&gt;&gt; </span>temp[0:5,0:10,:,:] = uniform(size=(5,10,nlats,nlons))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape after adding data = '</span>,temp.shape
<span class="py-output">temp shape after adding data =  (5, 10, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># levels have grown, but no values yet assigned.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'levels shape after adding pressure data = '</span>,levels.shape
<span class="py-output">levels shape after adding pressure data =  (10,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Note that the size of the levels variable grows when data is 
      appended along the <code>level</code> dimension of the variable 
      <code>temp</code>, even though no data has yet been assigned to 
      levels.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># now, assign data to levels dimension variable.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>levels[:] =  [1000.,850.,700.,500.,300.,250.,200.,150.,100.,50.]</pre>
      <p>However, that there are some differences between NumPy and netCDF 
      variable slicing rules. Slices behave as usual, being specified as a 
      <code>start:stop:step</code> triplet. Using a scalar integer index 
      <code>i</code> takes the ith element and reduces the rank of the 
      output array by one. Boolean array and integer sequence indexing 
      behaves differently for netCDF variables than for numpy arrays.  Only
      1-d boolean arrays and integer sequences are allowed, and these 
      indices work independently along each dimension (similar to the way 
      vector subscripts work in fortran).  This means that</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp[0, 0, [0,1,2,3], [0,1,2,3]]</pre>
      <p>returns an array of shape (4,4) when slicing a netCDF variable, 
      but for a numpy array it returns an array of shape (4,). Similarly, a
      netCDF variable of shape <code>(2,3,4,5)</code> indexed with 
      <code>[0, array([True, False, True]), array([False, True, True, 
      True]), :]</code> would return a <code>(2, 3, 5)</code> array. In 
      NumPy, this would raise an error since it would be equivalent to 
      <code>[0, [0,1], [1,2,3], :]</code>. While this behaviour can cause 
      some confusion for those used to NumPy's 'fancy indexing' rules, it 
      provides a very powerful way to extract data from multidimensional 
      netCDF variables by using logical operations on the dimension arrays 
      to create slices.</p>
      <p>For example,</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tempdat = temp[10:20:2, [1,3,6], lats&gt;0, lons&gt;0]</pre>
      <p>will extract time indices 10,12,14,16 and 18, pressure levels 850,
      500 and 200 hPa, all Northern Hemisphere latitudes and Eastern 
      Hemisphere longitudes, resulting in a numpy array of shape  (5, 3, 
      36, 71).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'shape of fancy temp slice = '</span>,tempdat.shape
<span class="py-output">shape of fancy temp slice =  (5, 3, 36, 71)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Time coordinate values pose a special challenge to netCDF users.  
      Most metadata standards (such as CF and COARDS) specify that time 
      should be measure relative to a fixed date using a certain calendar, 
      with units specified like <code>hours since YY:MM:DD hh-mm-ss</code>.
      These units can be awkward to deal with, without a utility to convert
      the values to and from calendar dates.  The functione called <a 
      href="netCDF4-module.html#num2date" class="link">num2date</a> and <a 
      href="netCDF4-module.html#date2num" class="link">date2num</a> are 
      provided with this package to do just that.  Here's an example of how
      they can be used:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># fill in times.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> datetime <span class="py-keyword">import</span> datetime, timedelta
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> num2date, date2num
<span class="py-prompt">&gt;&gt;&gt; </span>dates = [datetime(2001,3,1)+n*timedelta(hours=12) <span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(temp.shape[0])]
<span class="py-prompt">&gt;&gt;&gt; </span>times[:] = date2num(dates,units=times.units,calendar=times.calendar)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'time values (in units %s): '</span> % times.units+<span class="py-string">'\n'</span>,times[:]
<span class="py-output">time values (in units hours since January 1, 0001): </span>
<span class="py-output">[ 17533056.  17533068.  17533080.  17533092.  17533104.]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>dates = num2date(times[:],units=times.units,calendar=times.calendar)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'dates corresponding to time values:\n'</span>,dates
<span class="py-output">dates corresponding to time values:</span>
<span class="py-output">[2001-03-01 00:00:00 2001-03-01 12:00:00 2001-03-02 00:00:00</span>
<span class="py-output"> 2001-03-02 12:00:00 2001-03-03 00:00:00]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4-module.html#num2date" class="link">num2date</a> 
      converts numeric values of time in the specified <code>units</code> 
      and <code>calendar</code> to datetime objects, and <a 
      href="netCDF4-module.html#date2num" class="link">date2num</a> does 
      the reverse. All the calendars currently defined in the <a 
      href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
      target="_top">CF metadata convention</a> are supported. A function 
      called <a href="netCDF4-module.html#date2index" 
      class="link">date2index</a> is also provided which returns the 
      indices of a netCDF time variable corresponding to a sequence of 
      datetime instances.</p>
    <h2 class="heading">7) Reading data from a multi-file netCDF dataset.</h2>
      <p>If you want to read data from a variable that spans multiple 
      netCDF files, you can use the <a href="netCDF4.MFDataset-class.html" 
      class="link">MFDataset</a> class to read the data as if it were 
      contained in a single file. Instead of using a single filename to 
      create a <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> instance, create a <a 
      href="netCDF4.MFDataset-class.html" class="link">MFDataset</a> 
      instance with either a list of filenames, or a string with a wildcard
      (which is then converted to a sorted list of files using the python 
      glob module). Variables in the list of files that share the same 
      unlimited dimension are aggregated together, and can be sliced across
      multiple files.  To illustrate this, let's first create a bunch of 
      netCDF files with the same variable (with the same unlimited 
      dimension).  The files must in be in <code>NETCDF3_64BIT</code>, 
      <code>NETCDF3_CLASSIC</code> or <code>NETCDF4_CLASSIC format</code> 
      (<code>NETCDF4</code> formatted multi-file datasets are not 
      supported).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> nfile <span class="py-keyword">in</span> range(10):
<span class="py-prompt">&gt;&gt;&gt; </span>    f = Dataset(<span class="py-string">'mftest'</span>+repr(nfile)+<span class="py-string">'.nc'</span>,<span class="py-string">'w'</span>,format=<span class="py-string">'NETCDF4_CLASSIC'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>    f.createDimension(<span class="py-string">'x'</span>,None)
<span class="py-prompt">&gt;&gt;&gt; </span>    x = f.createVariable(<span class="py-string">'x'</span>,<span class="py-string">'i'</span>,(<span class="py-string">'x'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>    x[0:10] = numpy.arange(nfile*10,10*(nfile+1))
<span class="py-prompt">&gt;&gt;&gt; </span>    f.close()</pre>
      <p>Now read all the files back in at once with <a 
      href="netCDF4.MFDataset-class.html" class="link">MFDataset</a></p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> MFDataset
<span class="py-prompt">&gt;&gt;&gt; </span>f = MFDataset(<span class="py-string">'mftest*nc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.variables[<span class="py-string">'x'</span>][:]
<span class="py-output">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span>
<span class="py-output"> 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49</span>
<span class="py-output"> 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74</span>
<span class="py-output"> 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Note that MFDataset can only be used to read, not write, 
      multi-file datasets.</p>
    <h2 class="heading">8) Efficient compression of netCDF variables</h2>
      <p>Data stored in netCDF 4 <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> objects can be compressed and decompressed 
      on the fly. The parameters for the compression are determined by the 
      <code>zlib</code>, <code>complevel</code> and <code>shuffle</code> 
      keyword arguments to the <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method. To turn on compression, set 
      <code>zlib=True</code>.  The <code>complevel</code> keyword regulates
      the speed and efficiency of the compression (1 being fastest, but 
      lowest compression ratio, 9 being slowest but best compression 
      ratio). The default value of <code>complevel</code> is 6. Setting 
      <code>shuffle=False</code> will turn off the HDF5 shuffle filter, 
      which de-interlaces a block of data before compression by reordering 
      the bytes.  The shuffle filter can significantly improve compression 
      ratios, and is on by default.  Setting <code>fletcher32</code> 
      keyword argument to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> to <code>True</code> (it's 
      <code>False</code> by default) enables the Fletcher32 checksum 
      algorithm for error detection. It's also possible to set the HDF5 
      chunking parameters and endian-ness of the binary data stored in the 
      HDF5 file with the <code>chunksizes</code> and <code>endian</code> 
      keyword arguments to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a>.  These keyword arguments only are 
      relevant for <code>NETCDF4</code> and <code>NETCDF4_CLASSIC</code> 
      files (where the underlying file format is HDF5) and are silently 
      ignored if the file format is <code>NETCDF3_CLASSIC</code> or 
      <code>NETCDF3_64BIT</code>,</p>
      <p>If your data only has a certain number of digits of precision (say
      for example, it is temperature data that was measured with a 
      precision of 0.1 degrees), you can dramatically improve zlib 
      compression by quantizing (or truncating) the data using the 
      <code>least_significant_digit</code> keyword argument to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a>. The least significant digit is the 
      power of ten of the smallest decimal place in the data that is a 
      reliable value. For example if the data has a precision of 0.1, then 
      setting <code>least_significant_digit=1</code> will cause data the 
      data to be quantized using 
      <code>numpy.around(scale*data)/scale</code>, where scale = 2**bits, 
      and bits is determined so that a precision of 0.1 is retained (in 
      this case bits=4).  Effectively, this makes the compression 'lossy' 
      instead of 'lossless', that is some precision in the data is 
      sacrificed for the sake of disk space.</p>
      <p>In our example, try replacing the line</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      <p>with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True)</pre>
      <p>and then</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True,least_significant_digit=3)</pre>
      <p>and see how much smaller the resulting files are.</p>
    <h2 class="heading">9) Beyond homogenous arrays of a fixed type - compound data types</h2>
      <p>Compound data types map directly to numpy structured (a.k.a 
      'record' arrays).  Structured arrays are akin to C structs, or 
      derived types in Fortran. They allow for the construction of 
      table-like structures composed of combinations of other data types, 
      including other compound types. Compound types might be useful for 
      representing multiple parameter values at each point on a grid, or at
      each time and space location for scattered (point) data. You can then
      access all the information for a point by reading one variable, 
      instead of reading different parameters from different variables.  
      Compound data types are created from the corresponding numpy data 
      type using the <a 
      href="netCDF4.Dataset-class.html#createCompoundType" 
      class="link">createCompoundType</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. 
      Since there is no native complex data type in netcdf, compound types 
      are handy for storing numpy complex arrays.  Here's an example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>f = Dataset(<span class="py-string">'complex.nc'</span>,<span class="py-string">'w'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>size = 3 <span class="py-comment"># length of 1-d complex array</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create sample complex data.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac = numpy.exp(1j*(1.+numpy.linspace(0, numpy.pi, size)))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create complex128 compound data type.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>complex128 = numpy.dtype([(<span class="py-string">'real'</span>,numpy.float64),(<span class="py-string">'imag'</span>,numpy.float64)])
<span class="py-prompt">&gt;&gt;&gt; </span>complex128_t = f.createCompoundType(complex128,<span class="py-string">'complex128'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a variable with this data type, write some data to it.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.createDimension(<span class="py-string">'phony_dim'</span>,None)
<span class="py-prompt">&gt;&gt;&gt; </span>v = f.createVariable(<span class="py-string">'phony_var'</span>,complex128_t,<span class="py-string">'phony_dim'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(size,complex128)
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'real'</span>] = datac.real; data[<span class="py-string">'imag'</span>] = datac.imag
<span class="py-prompt">&gt;&gt;&gt; </span>v[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># close and reopen the file, check the contents.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.close(); f = Dataset(<span class="py-string">'complex.nc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>v = f.variables[<span class="py-string">'phony_var'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>datain = v[:] <span class="py-comment"># read in all the data into a numpy structured array</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create an empty numpy complex array</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac2 = numpy.empty(datain.shape,numpy.complex128)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># .. fill it with contents of structured array.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac2.real = datain[<span class="py-string">'real'</span>]; datac2.imag = datain[<span class="py-string">'imag'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> datac.dtype,datac
<span class="py-output">complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> datac2.dtype,datac2
<span class="py-output">complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Compound types can be nested, but you must create the 'inner' ones
      first. Here's a more complex example that uses a nested compound type
      to represent meteorological observations at stations:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># compound type example.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> chartostring, stringtoarr
<span class="py-prompt">&gt;&gt;&gt; </span>f = Dataset(<span class="py-string">'compound_example.nc'</span>,<span class="py-string">'w'</span>) <span class="py-comment"># create a new dataset.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create an unlimited  dimension call 'station'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.createDimension(<span class="py-string">'station'</span>,None)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># define a compound data type (can contain arrays, or nested compound types).</span>
<span class="py-prompt">&gt;&gt;&gt; </span>NUMCHARS = 80 <span class="py-comment"># number of characters to use in fixed-length strings.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>winddtype = numpy.dtype([(<span class="py-string">'speed'</span>,<span class="py-string">'f4'</span>),(<span class="py-string">'direction'</span>,<span class="py-string">'i4'</span>)])
<span class="py-prompt">&gt;&gt;&gt; </span>statdtype = numpy.dtype([(<span class="py-string">'latitude'</span>, <span class="py-string">'f4'</span>), (<span class="py-string">'longitude'</span>, <span class="py-string">'f4'</span>),
<span class="py-more">... </span>                         (<span class="py-string">'surface_wind'</span>,winddtype),
<span class="py-more">... </span>                         (<span class="py-string">'temp_sounding'</span>,<span class="py-string">'f4'</span>,10),(<span class="py-string">'press_sounding'</span>,<span class="py-string">'i4'</span>,10),
<span class="py-more">... </span>                         (<span class="py-string">'location_name'</span>,<span class="py-string">'S1'</span>,NUMCHARS)])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># use this data type definitions to create a compound data types</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># called using the createCompoundType Dataset method.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a compound type for vector wind which will be nested inside</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># the station data type. This must be done first!</span>
<span class="py-prompt">&gt;&gt;&gt; </span>wind_data_t = f.createCompoundType(winddtype,<span class="py-string">'wind_data'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># now that wind_data_t is defined, create the station data type.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>station_data_t = f.createCompoundType(statdtype,<span class="py-string">'station_data'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create nested compound data types to hold the units variable attribute.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>winddtype_units = numpy.dtype([(<span class="py-string">'speed'</span>,<span class="py-string">'S1'</span>,NUMCHARS),(<span class="py-string">'direction'</span>,<span class="py-string">'S1'</span>,NUMCHARS)])
<span class="py-prompt">&gt;&gt;&gt; </span>statdtype_units = numpy.dtype([(<span class="py-string">'latitude'</span>, <span class="py-string">'S1'</span>,NUMCHARS), (<span class="py-string">'longitude'</span>, <span class="py-string">'S1'</span>,NUMCHARS),
<span class="py-more">... </span>                               (<span class="py-string">'surface_wind'</span>,winddtype_units),
<span class="py-more">... </span>                               (<span class="py-string">'temp_sounding'</span>,<span class="py-string">'S1'</span>,NUMCHARS),
<span class="py-more">... </span>                               (<span class="py-string">'location_name'</span>,<span class="py-string">'S1'</span>,NUMCHARS),
<span class="py-more">... </span>                               (<span class="py-string">'press_sounding'</span>,<span class="py-string">'S1'</span>,NUMCHARS)])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create the wind_data_units type first, since it will nested inside</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># the station_data_units data type.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>wind_data_units_t = f.createCompoundType(winddtype_units,<span class="py-string">'wind_data_units'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>station_data_units_t =
<span class="py-more">... </span>f.createCompoundType(statdtype_units,<span class="py-string">'station_data_units'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a variable of of type 'station_data_t'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat = f.createVariable(<span class="py-string">'station_obs'</span>, station_data_t, (<span class="py-string">'station'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a numpy structured array, assign data to it.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(1,station_data_t)
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'latitude'</span>] = 40.
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'longitude'</span>] = -105.
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'surface_wind'</span>][<span class="py-string">'speed'</span>] = 12.5
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'surface_wind'</span>][<span class="py-string">'direction'</span>] = 270
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'temp_sounding'</span>] = (280.3,272.,270.,269.,266.,258.,254.1,250.,245.5,240.)
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'press_sounding'</span>] = range(800,300,-50)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># variable-length string datatypes are not supported inside compound types, so</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># to store strings in a compound data type, each string must be </span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># stored as fixed-size (in this case 80) array of characters.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'location_name'</span>] = stringtoarr(<span class="py-string">'Boulder, Colorado, USA'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># assign structured array to variable slice.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat[0] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># or just assign a tuple of values to variable slice</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># (will automatically be converted to a structured array).</span>
<span class="py-prompt">&gt;&gt;&gt; </span>statdat[1] = (40.78,-73.99,(-12.5,90),
<span class="py-more">... </span>             (290.2,282.5,279.,277.9,276.,266.,264.1,260.,255.5,243.),
<span class="py-more">... </span>             range(900,400,-50),stringtoarr(<span class="py-string">'New York, New York, USA'</span>,NUMCHARS))</pre>
      <p>All of the compound types defined for a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> are stored in 
      a Python dictionary, just like variables and dimensions:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.cmptypes
<span class="py-output">{'wind_data': &lt;netCDF4.CompoundType object at 0x14dd698&gt;,</span>
<span class="py-output"> 'station_data_units':&lt;netCDF4.CompoundType object at 0x14dd620&gt;,</span>
<span class="py-output"> 'wind_data_units':&lt;netCDF4.CompoundType object at 0x14dd648&gt;,</span>
<span class="py-output"> 'station_data':&lt;netCDF4.CompoundType object at 0x14dd670&gt;}</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Attributes cannot be assigned directly to compound type members, 
      However, a compound data type can be created to hold an attribute for
      each member. In this example we have created the compound types 
      <code>wind_data_units_t</code> and <code>station_data_units_t</code> 
      to hold the units attribute for each member of the nested compound 
      type <code>station_data_t</code>. Now we can fill a numpy array with 
      strings describing the units, then assign that array to the 
      <code>units</code> attribute of the station data variable. Note again
      that since there is no fixed-length string type in netCDF, we have to
      use arrays of characters to represent strings. Variable length 
      strings are supported (see the next section), but not inside compound
      types.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>windunits = numpy.empty(1,winddtype_units)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units = numpy.empty(1,statdtype_units)
<span class="py-prompt">&gt;&gt;&gt; </span>windunits[<span class="py-string">'speed'</span>] = stringtoarr(<span class="py-string">'m/s'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>windunits[<span class="py-string">'direction'</span>] = stringtoarr(<span class="py-string">'degrees'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'latitude'</span>] = stringtoarr(<span class="py-string">'degrees north'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'longitude'</span>] = stringtoarr(<span class="py-string">'degrees west'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'surface_wind'</span>] = windunits
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'location_name'</span>] = stringtoarr(<span class="py-string">'None'</span>, NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'temp_sounding'</span>] = stringtoarr(<span class="py-string">'Kelvin'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>stationobs_units[<span class="py-string">'press_sounding'</span>] = stringtoarr(<span class="py-string">'hPa'</span>,NUMCHARS)
<span class="py-prompt">&gt;&gt;&gt; </span>statdat.units = stationobs_units</pre>
      <p>Now let's close the file, reopen it, and see what's in there. The 
      command line utility <code>ncdump</code> can also be used to get a 
      quick look at the contents of the file.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># close and reopen the file.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.close(); f = Dataset(<span class="py-string">'compound_example.nc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>statdat = f.variables[<span class="py-string">'station_obs'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># print out data in variable.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># (also, try 'ncdump compound_example.nc' on the command line</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment">#  to see what's in the file)</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'data in a variable of compound type:'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'----'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> data <span class="py-keyword">in</span> statdat[:]:
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">for</span> name <span class="py-keyword">in</span> statdat.dtype.names:
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">if</span> data[name].dtype.kind == <span class="py-string">'S'</span>: <span class="py-comment"># a string</span>
<span class="py-prompt">&gt;&gt;&gt; </span>            <span class="py-comment"># convert array of characters back to a string for display.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>            <span class="py-keyword">print</span> name,<span class="py-string">': value ='</span>,chartostring(data[name]),
<span class="py-more">... </span>            <span class="py-string">': units='</span>,chartostring(statdat.units[name])
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">elif</span> data[name].dtype.kind == <span class="py-string">'V'</span>: <span class="py-comment"># a nested compound type</span>
<span class="py-prompt">&gt;&gt;&gt; </span>            <span class="py-keyword">print</span> name,data[name].dtype.names,<span class="py-string">': value='</span>,data[name],<span class="py-string">': units='</span>,
<span class="py-more">... </span>            tuple([<span class="py-string">''</span>.join(u.tolist()) <span class="py-keyword">for</span> u <span class="py-keyword">in</span> statdat.units[name]])
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">else</span>: <span class="py-comment"># a numeric type.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>            <span class="py-keyword">print</span> name,<span class="py-string">': value='</span>,data[name],<span class="py-string">': units='</span>,chartostring(statdat.units[name])
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">print</span> <span class="py-string">'----'</span>
<span class="py-output">data in a variable of compound type:</span>
<span class="py-output">----</span>
<span class="py-output">latitude : value= 40.0 : units= degrees north</span>
<span class="py-output">longitude : value= -105.0 : units= degrees west</span>
<span class="py-output">surface_wind ('speed', 'direction') : value= (12.5, 270) : units= ('m/s', 'degrees')</span>
<span class="py-output">temp_sounding : value= [280.3 272. 270. 269. 266. 258. 254.1 250.245.5 240.] : units= Kelvin</span>
<span class="py-output">press_sounding : value= [800 750 700 650 600 550 500 450 400 350] : units= hPa</span>
<span class="py-output">location_name : value = Boulder, Colorado, USA : units= None</span>
<span class="py-output">----</span>
<span class="py-output">latitude : value= 40.78 : units= degrees north</span>
<span class="py-output">longitude : value= -73.99 : units= degrees west</span>
<span class="py-output">surface_wind ('speed', 'direction') : value= (-12.5, 90) : units= ('m/s','degrees')</span>
<span class="py-output">temp_sounding : value= [290.2 282.5 279. 277.9 276. 266. 264.1 260. 255.5 243.] : units= Kelvin</span>
<span class="py-output">press_sounding : value= [900 850 800 750 700 650 600 550 500 450] : units= hPa</span>
<span class="py-output">location_name : value = New York, New York, USA : units= None</span>
<span class="py-output">----</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.close()</pre>
    <h2 class="heading">10) Variable-length (vlen) data types.</h2>
      <p>NetCDF 4 has support for variable-length or &quot;ragged&quot; 
      arrays.  These are arrays of variable length sequences having the 
      same type. To create a variable-length data type, use the <a 
      href="netCDF4.Dataset-class.html#createVLType" 
      class="link">createVLType</a> method method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>f = Dataset(<span class="py-string">'tst_vlen.nc'</span>,<span class="py-string">'w'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>vlen_t = f.createVLType(numpy.int32, <span class="py-string">'phony_vlen'</span>)</pre>
      <p>The numpy datatype of the variable-length sequences and the name 
      of the new datatype must be specified. Any of the primitive datatypes
      can be used (signed and unsigned integers, 32 and 64 bit floats, and 
      characters), but compound data types cannot. A new variable can then 
      be created using this datatype.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = f.createDimension(<span class="py-string">'x'</span>,3)
<span class="py-prompt">&gt;&gt;&gt; </span>y = f.createDimension(<span class="py-string">'y'</span>,4)
<span class="py-prompt">&gt;&gt;&gt; </span>vlvar = f.createVariable(<span class="py-string">'phony_vlen_var'</span>, vlen_t, (<span class="py-string">'y'</span>,<span class="py-string">'x'</span>))</pre>
      <p>Since there is no native vlen datatype in numpy, vlen arrays are 
      represented in python as object arrays (arrays of dtype 
      <code>object</code>). These are arrays whose elements are Python 
      object pointers, and can contain any type of python object. For this 
      application, they must contain 1-D numpy arrays all of the same type 
      but of varying length. In this case, they contain 1-D numpy 
      <code>int32</code> arrays of random length betwee 1 and 10.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> random
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(len(y)*len(x),object)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(len(y)*len(x)):
<span class="py-prompt">&gt;&gt;&gt; </span>   data[n] = numpy.arange(random.randint(1,10),dtype=<span class="py-string">'int32'</span>)+1
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.reshape(data,(len(y),len(x)))
<span class="py-prompt">&gt;&gt;&gt; </span>vlvar[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'vlen variable =\n'</span>,vlvar[:]
<span class="py-output">vlen variable =</span>
<span class="py-output">[[[ 1  2  3  4  5  6  7  8  9 10] [1 2 3 4 5] [1 2 3 4 5 6 7 8]]</span>
<span class="py-output"> [[1 2 3 4 5 6 7] [1 2 3 4 5 6] [1 2 3 4 5]]</span>
<span class="py-output"> [[1 2 3 4 5] [1 2 3 4] [1]]</span>
<span class="py-output"> [[ 1  2  3  4  5  6  7  8  9 10] [ 1  2  3  4  5  6  7  8  9 10]</span>
<span class="py-output">  [1 2 3 4 5 6 7 8]]]</span></pre>
      <p>Numpy object arrays containing python strings can also be written 
      as vlen variables,  For vlen strings, you don't need to create a vlen
      data type. Instead, simply use the python <code>str</code> builtin 
      instead of a numpy datatype when calling the <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>z = f.createDimension(<span class="py-string">'z'</span>,10)
<span class="py-prompt">&gt;&gt;&gt; </span>strvar = rootgrp.createVariable(<span class="py-string">'strvar'</span>, str, <span class="py-string">'z'</span>)</pre>
      <p>In this example, an object array is filled with random python 
      strings with random lengths between 2 and 12 characters, and the data
      in the object array is assigned to the vlen string variable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>chars = <span class="py-string">'1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data = NP.empty(10,<span class="py-string">'O'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(10):
<span class="py-prompt">&gt;&gt;&gt; </span>    stringlen = random.randint(2,12)
<span class="py-prompt">&gt;&gt;&gt; </span>    data[n] = <span class="py-string">''</span>.join([random.choice(chars) <span class="py-keyword">for</span> i <span class="py-keyword">in</span> range(stringlen)])
<span class="py-prompt">&gt;&gt;&gt; </span>strvar[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'variable-length string variable:\n'</span>,strvar[:]
<span class="py-output">variable-length string variable:</span>
<span class="py-output">[aDy29jPt jd7aplD b8t4RM jHh8hq KtaPWF9cQj Q1hHN5WoXSiT MMxsVeq td LUzvVTzj</span>
<span class="py-output"> 5DS9X8S]</span></pre>
      <p>All of the code in this tutorial is available in 
      <code>examples/tutorial.py</code>, Unit tests are in the 
      <code>test</code> directory.</p>

<hr />
<div class="fields">      <p><strong>Contact:</strong>
        Jeffrey Whitaker &lt;jeffrey.s.whitaker@noaa.gov&gt;
      </p>
      <p><strong>Copyright:</strong>
        2008 by Jeffrey Whitaker.
      </p>
      <p><strong>License:</strong>
        Permission to use, copy, modify, and distribute this software and 
        its documentation for any purpose and without fee is hereby 
        granted, provided that the above copyright notice appear in all 
        copies and that both the copyright notice and this permission 
        notice appear in supporting documentation. THE AUTHOR DISCLAIMS ALL
        WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED 
        WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE 
        AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
        OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR 
        PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER 
        TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
        PERFORMANCE OF THIS SOFTWARE.
      </p>
      <p><strong>Version:</strong>
        0.9.2
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.CompoundType-class.html" class="summary-name">CompoundType</a><br />
      A <a href="netCDF4.CompoundType-class.html" 
        class="link">CompoundType</a> instance is used to describe a 
        compound data type.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dataset-class.html" class="summary-name">Dataset</a><br />
      Dataset(self, filename, mode=&quot;r&quot;, clobber=True, 
        format='NETCDF4')
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dimension-class.html" class="summary-name">Dimension</a><br />
      Dimension(self, group, name, size=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Group-class.html" class="summary-name">Group</a><br />
      Group(self, parent, name)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.MFDataset-class.html" class="summary-name">MFDataset</a><br />
      MFDataset(self, files, check=False, exclude=[])
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.VLType-class.html" class="summary-name">VLType</a><br />
      A <a href="netCDF4.VLType-class.html" class="link">VLType</a> 
        instance is used to describe a variable length (VLEN) data type.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Variable-class.html" class="summary-name">Variable</a><br />
      Variable(self, group, name, datatype, dimensions=(), zlib=False, 
        complevel=6, shuffle=True, fletcher32=False, contiguous=False, 
        chunksizes=None, endian='native', 
        least_significant_digit=None,fill_value=None)
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#chartostring" class="summary-sig-name">chartostring</a>(<span class="summary-sig-arg">b</span>)</span><br />
      convert a character array to a string array with one less dimension.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#date2index" class="summary-sig-name">date2index</a>(<span class="summary-sig-arg">dates</span>,
        <span class="summary-sig-arg">nctime</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">select</span>=<span class="summary-sig-default">'exact'</span>)</span><br />
      Return indices of a netCDF time variable corresponding to the given 
      dates.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#date2num" class="summary-sig-name">date2num</a>(<span class="summary-sig-arg">dates</span>,
        <span class="summary-sig-arg">units</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">'standard'</span>)</span><br />
      Return numeric time values given datetime objects.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="getlibversion"></a><span class="summary-sig-name">getlibversion</span>()</span><br />
      returns a string describing the version of the netcdf library used to
      build the module, and when it was built.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#num2date" class="summary-sig-name">num2date</a>(<span class="summary-sig-arg">times</span>,
        <span class="summary-sig-arg">units</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">'standard'</span>)</span><br />
      Return datetime objects given numeric time values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#stringtoarr" class="summary-sig-name">stringtoarr</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">NUMCHARS</span>)</span><br />
      convert a string to a character array of length NUMCHARS</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#stringtochar" class="summary-sig-name">stringtochar</a>(<span class="summary-sig-arg">a</span>)</span><br />
      convert a string array to a character array with one extra dimension</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Variables</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__hdf5libversion__"></a><span class="summary-name">__hdf5libversion__</span> = <code title="'1.8.4-patch1'"><code class="variable-quote">'</code><code class="variable-string">1.8.4-patch1</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__netcdf4libversion__"></a><span class="summary-name">__netcdf4libversion__</span> = <code title="'4.1.1-rc1'"><code class="variable-quote">'</code><code class="variable-string">4.1.1-rc1</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="None">None</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__required_hdf5version__"></a><span class="summary-name">__required_hdf5version__</span> = <code title="'1.8.4-patch1'"><code class="variable-quote">'</code><code class="variable-string">1.8.4-patch1</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__required_netcdf4version__"></a><span class="summary-name">__required_netcdf4version__</span> = <code title="'4.1.1'"><code class="variable-quote">'</code><code class="variable-string">4.1.1</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="chartostring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">chartostring</span>(<span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a character array to a string array with one less 
  dimension.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>b</code></strong> - Input character array (numpy datatype 'S1'). Will be converted to
          a array of strings, where each string has a fixed length of 
          b.shape[-1] characters.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A numpy string array with datatype 'SN' and shape b.shape[:-1], 
          where N=b.shape[-1].</dd>
  </dl>
</td></tr></table>
</div>
<a name="date2index"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">date2index</span>(<span class="sig-arg">dates</span>,
        <span class="sig-arg">nctime</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">select</span>=<span class="sig-default">'exact'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return indices of a netCDF time variable corresponding to the given 
  dates.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>dates</code></strong> - A datetime object or a sequence of datetime objects. The datetime
          objects should not include a time-zone offset.</li>
        <li><strong class="pname"><code>nctime</code></strong> - A netCDF time variable object. The nctime object must have a 
          <code>units</code> attribute.</li>
        <li><strong class="pname"><code>calendar</code></strong> - Describes the calendar used in the time calculation. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar If <code>calendar</code> is None,
          its value is given by <code>nctime.calendar</code> or 
          <code>standard</code> if no such attribute exists.</li>
        <li><strong class="pname"><code>select</code></strong> - <code>'exact', 'before', 'after', 'nearest'</code> The index 
          selection method. <code>exact</code> will return the indices 
          perfectly matching the dates given. <code>before</code> and 
          <code>after</code> will return the indices corresponding to the 
          dates just before or just after the given dates if an exact match
          cannot be found. <code>nearest</code> will return the indices 
          that correspond to the closest dates.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>an index (indices) of the netCDF time variable corresponding to 
          the given datetime object(s).</dd>
  </dl>
</td></tr></table>
</div>
<a name="date2num"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">date2num</span>(<span class="sig-arg">dates</span>,
        <span class="sig-arg">units</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">'standard'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return numeric time values given datetime objects. The units of the 
  numeric time values are described by the <code class="link">units</code> 
  argument and the <code class="link">calendar</code> keyword. The datetime
  objects must be in UTC with no time-zone offset.  If there is a time-zone
  offset in <code>units</code>, it will be applied to the returned numeric 
  values.</p>
  <p>Like the matplotlib <code>date2num</code> function, except that it 
  allows for different units and calendars.  Behaves the same if 
  <code>units = 'days since 0001-01-01 00:00:00'</code> and <code>calendar 
  = 'proleptic_gregorian'</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>dates</code></strong> - A datetime object or a sequence of datetime objects. The datetime
          objects should not include a time-zone offset.</li>
        <li><strong class="pname"><code>units</code></strong> - a string of the form <code>'<b>time units</b> since <b>reference 
          time</b></code>' describing the time units. <b><code>time 
          units</code></b> can be days, hours, minutes or seconds.  
          <b><code>reference time</code></b> is the time origin. A valid 
          choice would be units=<code>'hours since 1800-01-01 00:00:00 
          -6:00'</code>.</li>
        <li><strong class="pname"><code>calendar</code></strong> - describes the calendar used in the time calculations. All the 
          values currently defined in the <a 
          href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
          target="_top">CF metadata convention</a> are supported. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>a numeric time value, or an array of numeric time values.
          <p>The maximum resolution of the numeric time values is 1 
          second.</p></dd>
  </dl>
</td></tr></table>
</div>
<a name="num2date"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">num2date</span>(<span class="sig-arg">times</span>,
        <span class="sig-arg">units</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">'standard'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return datetime objects given numeric time values. The units of the 
  numeric time values are described by the <code>units</code> argument and 
  the <code>calendar</code> keyword. The returned datetime objects 
  represent UTC with no time-zone offset, even if the specified 
  <code>units</code> contain a time-zone offset.</p>
  <p>Like the matplotlib <code>num2date</code> function, except that it 
  allows for different units and calendars.  Behaves the same if 
  <code>units = 'days since 001-01-01 00:00:00'</code> and <code>calendar =
  'proleptic_gregorian'</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>times</code></strong> - numeric time values. Maximum resolution is 1 second.</li>
        <li><strong class="pname"><code>units</code></strong> - a string of the form <code>'<b>time units</b> since <b>reference 
          time</b></code>' describing the time units. <b><code>time 
          units</code></b> can be days, hours, minutes or seconds.  
          <b><code>reference time</code></b> is the time origin. A valid 
          choice would be units=<code>'hours since 1800-01-01 00:00:00 
          -6:00'</code>.</li>
        <li><strong class="pname"><code>calendar</code></strong> - describes the calendar used in the time calculations. All the 
          values currently defined in the <a 
          href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
          target="_top">CF metadata convention</a> are supported. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>a datetime instance, or an array of datetime instances.
          <p>The datetime instances returned are 'real' python datetime 
          objects if the date falls in the Gregorian calendar (i.e. 
          <code>calendar='proleptic_gregorian'</code>, or <code>calendar = 
          'standard'</code> or <code>'gregorian'</code> and the date is 
          after 1582-10-15). Otherwise, they are 'phony' datetime objects 
          which support some but not all the methods of 'real' python 
          datetime objects.  This is because the python datetime module 
          cannot the uses the <code>'proleptic_gregorian'</code> calendar, 
          even before the switch occured from the Julian calendar in 1582. 
          The datetime instances do not contain a time-zone offset, even if
          the specified <code>units</code> contains one.</p></dd>
  </dl>
</td></tr></table>
</div>
<a name="stringtoarr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">stringtoarr</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">NUMCHARS</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a string to a character array of length NUMCHARS</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>a</code></strong> - Input python string.</li>
        <li><strong class="pname"><code>NUMCHARS</code></strong> - number of characters used to represent string (if len(a) &lt; 
          NUMCHARS, it will be padded on the right with blanks).</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A rank 1 numpy character array of length NUMCHARS with datatype 
          'S1'</dd>
  </dl>
</td></tr></table>
</div>
<a name="stringtochar"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">stringtochar</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a string array to a character array with one extra 
  dimension</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>a</code></strong> - Input numpy string array with numpy datatype 'SN', where N is the
          number of characters in each string.  Will be converted to an 
          array of characters (datatype 'S1') of shape a.shape + (N,).</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A numpy character array with datatype 'S1' and shape a.shape + 
          (N,), where N is the length of each string in a.</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Thu Jul  8 10:58:35 2010
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
